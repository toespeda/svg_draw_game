<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Test</title>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <style>
            html, body {
                height:100%;
            }
            body {
                margin:0;
                padding: 10px;
                background-color: #eee;
            }
            #editor {
                float: left;
            }
            svg {
                background-color: #fff;
            }
            #layers {
                float: left;
            }
            #layers li {
                cursor: default;
            }
            #layers .remove {
                cursor: pointer;
                margin:0 5px;
            }
            #controllers {
                clear: left;
                padding: 10px 0;
            }
            #examples {
                display: none;
            }
        </style>
    </head>
    <body>

        <div id="examples">
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
                <!--                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80, 265 80, 235 40 C235 80, 225 80, 225 80"></path>-->
                <!--                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80"></path>-->
                <!--                <circle stroke="#000000" stroke-width="3" fill="transparent" cx="182" cy="124" r="36.235341863986875"></circle>-->
                <!--                <ellipse stroke="#000000" stroke-width="3" fill="transparent" cx="100" cy="132" rx="36" ry="52.5"></ellipse>-->

                <!--                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80, 265 80, 235 40 C235 80, 225 80, 225 80"></path>-->

                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M152 50 L84 121" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M152 50 L236 110" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M84 121 L128 124" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M128 124 L70 177" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M185 121 L244 165" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M192 185 L244 165" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M44 280 L126 183" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M280 270 L189 184" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M280 270 L187 288" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M236 110 L185 121" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M126 183 L70 177" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M44 280 L134 291" opacity="1"></path>
            </svg>
        </div>
        
        <div id="editor" class="test">
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
<!--                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80, 265 80, 235 40 C235 80, 225 80, 225 80"></path>-->
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80"></path>
                <circle stroke="#000000" stroke-width="3" fill="transparent" cx="182" cy="124" r="36.235341863986875"></circle>
                <ellipse stroke="#000000" stroke-width="3" fill="transparent" cx="100" cy="132" rx="36" ry="52.5"></ellipse>

                <!--                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80, 265 80, 235 40 C235 80, 225 80, 225 80"></path>-->

            </svg>
        </div>
        <ol id="layers"></ol>
        <div id="controllers">
            <button id="play">Play</button>
        </div>
        
        <script>

            let parsePath = function(str) {
                let match;
                let commands = /[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g;
                //Get the matches first
                let results = [];
                while ((match = commands.exec(str)) !== null) {
                    results.push(match);
                };
                let data = [];
                let digits = /-?[0-9]*\.?\d+/g;
                for (let x=0; x<results.length; x++) {
                    //Get the string value without command, and parse float
                    let params = (str.substring(results[x].index+1, results[x+1] ? results[x+1].index : str.length).match(digits) || []).map(parseFloat);
                    if (false) {
                        //Split into chunks of xy params
                        let chunks = [];
                        let positions = ["left","top"];
                        for (let y = 0; y<params.length; y += 2) {
                            let coords = params.slice(y, y + 2);
                            chunks.push(positions.reduce((acc, element, index) => {
                                return {
                                    ...acc,
                                    [element]: coords[index],
                                };
                            }, {}));
                        }
                        data.push({
                            command : results[x][0],
                            params : chunks
                        });
                    } else {
                        data.push({
                            command : results[x][0],
                            params : params
                        });
                    }

                }
                return data;
            }

            let editor = document.querySelector("#editor")

            let svg = editor.querySelector("svg");

            let layers = document.querySelector("#layers");

            let shapes = [];

            let type = "ellipse";

            let draw = 0;

            let createElement = function(type){
                let el = document.createElementNS("http://www.w3.org/2000/svg", type);
                el.setAttribute("stroke","#000000");
                el.setAttribute("stroke-width",3);
                // el.setAttribute("opacity",.8);
                if (type === "path") {
                    el.setAttribute("fill","none");
                    el.setAttribute("stroke-linejoin","round");
                    el.setAttribute("d","");
                } else if (type === "circle") {
                    el.setAttribute("fill","transparent");
                    el.setAttribute("cx",0);
                    el.setAttribute("cy",0);
                    el.setAttribute("r",0);
                } else if (type === "ellipse") {
                    el.setAttribute("fill","transparent");
                    el.setAttribute("cx",0);
                    el.setAttribute("cy",0);
                    el.setAttribute("rx",0);
                    el.setAttribute("ry",0);
                }
                return el;
            };

            let addShape = function(Shape) {
                shapes.push(Shape);
                let b = document.createElement('li');
                b.innerHTML = Shape.type + '<span class="remove">x</span>';
                layers.appendChild(b);
            };

            let createShape = function(type, startPos) {
                let Shape = {
                    type : type,
                    // start : startPos,
                    // end : startPos
                };
                Shape.el = createElement(type);
                if (type === "path") {
                    Shape.d = [];
                    if (startPos) {
                        Shape.d.push({
                            command:"M",
                            params:[startPos.left, startPos.top]
                        });
                    }
                } else if (type === "circle") {
                    if (startPos) {
                        Shape.cx = startPos.left;
                        Shape.cy = startPos.top;
                    }
                    Shape.r = null;
                } else if (type === "ellipse") {
                    if (startPos) {
                        Shape.cx = startPos.left;
                        Shape.cy = startPos.top;
                    }
                    Shape.rx = null;
                    Shape.ry = null;
                }
                svg.appendChild(Shape.el);
                return Shape;
            };

            // let parsePath = function(str){
            //     let r = /(M|L)\s*(\d+)\s(\d+)/ig;
            //     let m = [...str.matchAll(r)];
            //     if (m.length) {
            //         return {
            //             start: {
            //                 left: +m[0][2],
            //                 top: +m[0][3]
            //             },
            //             end: {
            //                 left: +m[1][2],
            //                 top: +m[1][3]
            //             }
            //         }
            //     }
            //     return null;
            // };

            let parseShape = function(el){
                let Shape = {
                    type : el.nodeName.toLowerCase(),
                    el : el
                };
                if (Shape.type === "path") {
                    let path = parsePath(el.getAttribute("d"));
                    // for (let m in path) {
                    //     if (path[m].command == "M") {
                    //         //Shape.start = path[0].params[0]
                    //         Shape.start = {
                    //             left : path[m].params[0],
                    //             top : path[m].params[1]
                    //         }
                    //     }
                    //     if (path[m].command == "L") {
                    //         //Shape.end = path[1].params[0]
                    //         Shape.end = {
                    //             left : path[m].params[0],
                    //             top : path[m].params[1]
                    //         }
                    //     }
                    // }
                    Shape.d = path;
                } else if (Shape.type === "circle") {

                    // Shape.end = {
                    //     left : +el.getAttribute("cx"),
                    //     top : +el.getAttribute("cy")
                    // };
                    // Shape.start = Shape.end;
                    Shape.r = +el.getAttribute("r");
                    Shape.cx = +el.getAttribute("cx");
                    Shape.cy = +el.getAttribute("cy");

                } else if (Shape.type === "ellipse") {
                    // Shape.end = {
                    //     left : +el.getAttribute("cx"),
                    //     top : +el.getAttribute("cy")
                    // };
                    // Shape.start = Shape.end;
                    Shape.rx = +el.getAttribute("rx");
                    Shape.ry = +el.getAttribute("ry");
                    Shape.cx = +el.getAttribute("cx");
                    Shape.cy = +el.getAttribute("cy");
                }

                console.log(Shape);
                return Shape;
            };

            //Convert existing
            [...svg.children].forEach(el => {
                addShape(parseShape(el));
            });

            let getShape = function(el){
                for (let i = 0; i < shapes.length; i++) {
                    if (shapes[i].el === el) {
                        return shapes[i];
                    }
                }
            };

            let getDistance = function(a, b){
                let startx = a.left - b.left;
                let starty = a.top - b.top;
                return Math.sqrt(startx*startx+starty*starty);
            };

            document.addEventListener("keyup", (e) => {

                if (e.key === "1") {
                    type = "path";
                }
                if (e.key === "2") {
                    type = "circle";
                }
                if (e.key === "3") {
                    type = "ellipse";
                }
                if (e.key === "l") {
                    draw = 1;
                }
                if (e.key === "m") {
                    draw = 0;
                }
                // if (e.key === "Delete") {
                //     console.log(Shape);
                // }
            });

            svg.addEventListener("mousedown", (e) => {

                let Shape = null;

                let moving = 0;

                let resizing = 0;

                let offset = svg.getBoundingClientRect();

                let getPos = function(e){
                    return {
                        left : e.clientX - offset.left,
                        top : e.clientY - offset.top
                    };
                };

                let startPos = getPos(e);

                let lastPos = startPos;

                let paths = svg.querySelectorAll("path");

                let testProximity = function(pos, c){
                    // let d = getProximity(pos, c);

                    let start = {};
                    let end = {};

                    for (let m in c.d) {
                        if (c.d[m].command == "M") {
                            start["left"] = c.d[m].params[0];
                            start["top"] = c.d[m].params[1];
                        }
                        if (c.d[m].command == "L") {
                            end["left"] = c.d[m].params[0];
                            end["top"] = c.d[m].params[1];
                        }
                    }

                    let d = {
                        start : getDistance(pos, start),
                        end : getDistance(pos, end)
                    }
                    if (d.start < d.end && d.start < 10) {
                        return [start, end];
                    } else if (d.end < 10) {
                        return [end, start];
                    } else {
                        return null;
                    }
                };

                let getEdges = function(pos, shape){
                    let s = [];
                    for (let i = 0; i < paths.length; i++) {
                        let el = paths[i];
                        if (!shape || el !== shape) {
                            let c = getShape(el);
                            let proximity = c ? testProximity(pos, c) : null;
                            if (proximity) {
                                s.push({
                                    shape : el,
                                    path : proximity
                                });
                            }
                        }
                    }
                    return s;
                };

                let edges = getEdges(startPos);

                if (edges.length) {

                    if (draw) {

                        //Shape.start = edges[0].path[0];
                        Shape = createShape(type, edges[0].path[0]);
                        addShape(Shape);

                    } else if (type === edges[0].shape.nodeName) {

                        Shape = getShape(edges[0].shape);

                        for (let m in Shape.d) {
                            if (Shape.d[m].command == "M") {
                                Shape.d[m].params[0] = edges[0].path[1].left;
                                Shape.d[m].params[1] = edges[0].path[1].top;
                            }
                            if (Shape.d[m].command == "L") {
                                Shape.d[m].params[0] = edges[0].path[0].left;
                                Shape.d[m].params[1] = edges[0].path[0].top;
                            }
                        }

                        // Shape.start = edges[0].path[1];
                        // Shape.end = edges[0].path[0];

                    }

                } else if (!draw && e.target.nodeName.match(/(path|circle|ellipse)/)) {

                    Shape = getShape(e.target);

                    if (Shape.type === "circle") {

                        // console.log("Shape", Shape);
                        // console.log("Shape.end", Shape.end);

                        if (Shape.r - getDistance(startPos, {
                            left:Shape.cx,
                            top:Shape.cy
                        }) < 5) {
                            // Shape.start = Shape.end;//Reset
                            resizing = 1;
                        } else {
                            moving = 1;
                        }

                    } else if (Shape.type === "ellipse") {

                        let dx = Shape.cx - startPos.left;
                        let dy = Shape.cy - startPos.top;

                        let theta = Math.atan2(dy, dx); // range (-PI, PI]

                        let a = Shape.rx;
                        let b = Shape.ry;

                        let x = a*a*Math.sin(theta)*Math.sin(theta);
                        let y = b*b*Math.cos(theta)*Math.cos(theta);

                        let r = (a*b)/Math.sqrt(x+y);

                        if (r - getDistance(startPos, {
                            left:Shape.cx,
                            top:Shape.cy
                        }) < 5) {
                            // Shape.start = Shape.end;//Reset
                            resizing = 1;
                        } else {
                            moving = 1;
                        }

                    } else {

                        moving = 1;

                    }

                }

                if (!Shape) {
                    Shape = createShape(type, startPos);
                    addShape(Shape);
                }

                let move = function(e) {

                    let pos = getPos(e);

                    let diff = {
                        left : pos.left - lastPos.left,
                        top : pos.top - lastPos.top,
                    };

                    lastPos = pos;

                    if (Shape.type === "path") {

                        if (moving) {

                            //New
                            Shape.d.forEach(t => {
                                for (var v in t.params) {
                                    t.params[v] += diff[v%2 ? "top" : "left"];
                                }
                            });

                            // Shape.start.left += diff.left;
                            // Shape.start.top += diff.top;
                            // Shape.end.left += diff.left;
                            // Shape.end.top += diff.top;

                        } else {

                            let edges = getEdges(pos, Shape.el);

                            if (edges.length) {
                                pos = edges[0].path[0];
                            }

                            //New
                            let point = null;
                            for (let m in Shape.d) {
                                if (Shape.d[m].command == "L") {
                                    point = Shape.d[m];
                                }
                            }

                            if (point){
                                point.params = [pos.left, pos.top];
                            } else {
                                Shape.d.push({
                                    command : "L",
                                    params : [pos.left, pos.top]
                                });
                            }

                            //Shape.end = pos;

                        }

                        //New
                        let d = Shape.d.map(function(command) {
                            return command.command + ' ' + command.params.join(',');
                        }).join(' ');

                        Shape.el.setAttribute("d", d);

                        // Shape.el.setAttribute("d", "M" + Shape.start.left + " " + Shape.start.top + " " + "L" + Shape.end.left + " " + Shape.end.top);

                    } else if (Shape.type === "circle") {

                        if (moving) {

                            // Shape.end.left += diff.left;
                            // Shape.end.top += diff.top;

                            Shape.cx += diff.left;
                            Shape.cy += diff.top;

                            Shape.el.setAttribute("cx", Shape.cx);
                            Shape.el.setAttribute("cy", Shape.cy);

                        } else if (resizing) {

                            Shape.r = getDistance(pos, {
                                left:Shape.cx,
                                top:Shape.cy
                            });

                            Shape.el.setAttribute("r", Shape.r);

                        } else {

                            Shape.cx = startPos.left;
                            Shape.cy = startPos.top;

                            //Shape.end = pos;

                            Shape.r = getDistance(startPos, pos);

                            Shape.el.setAttribute("r", Shape.r);

                            // console.log("Shape.end", Shape.end);

                            Shape.el.setAttribute("cx", Shape.cx);
                            Shape.el.setAttribute("cy", Shape.cy);

                        }

                    } else if (Shape.type === "ellipse") {

                        if (moving) {

                            Shape.cx += diff.left;
                            Shape.cy += diff.top;

                            Shape.el.setAttribute("cx", Shape.cx);
                            Shape.el.setAttribute("cy", Shape.cy);

                        } else if (resizing) {

                            Shape.rx += diff.left;
                            Shape.ry += diff.top;

                            Shape.el.setAttribute("rx", Shape.rx);
                            Shape.el.setAttribute("ry", Shape.ry);

                        } else {

                            Shape.rx = Math.abs(pos.left - startPos.left);
                            Shape.ry = Math.abs(pos.top - startPos.top);

                            Shape.cx += diff.left/2;
                            Shape.cy += diff.top/2;

                            // Shape.end.left += diff.left/2;
                            // Shape.end.top += diff.top/2;

                            Shape.el.setAttribute("rx", Shape.rx);
                            Shape.el.setAttribute("ry", Shape.ry);

                            Shape.el.setAttribute("cx", Shape.cx);
                            Shape.el.setAttribute("cy", Shape.cy);

                        }

                    }

                };

                let stop = function(){
                    svg.removeEventListener("mousemove", move);
                    svg.removeEventListener("mouseup", stop);
                    //Update shape preview

                };

                svg.addEventListener("mousemove", move, false);
                svg.addEventListener("mouseup", stop);

            });

            layers.addEventListener("mousedown", (e) => {

                let getPos = function(e){
                    return {
                        left : e.clientX,
                        top : e.clientY
                    };
                };

                if (e.target.nodeName.toLowerCase() === "span") {

                    let elements = [...layers.childNodes];

                    let startIndex = elements.indexOf(e.target.parentNode);

                    let Shape = shapes[startIndex];

                    Shape.el.remove();

                    shapes.splice(startIndex, 1);

                    e.target.parentNode.remove();

                }

                if (e.target.nodeName.toLowerCase() === "li") {

                    let elements = [...layers.childNodes];//Sortable elements

                    const target = e.target;

                    let startIndex = elements.indexOf(target);
                    let hoverIndex = null;
                    let endIndex = startIndex;

                    let targetDisplay = window.getComputedStyle(target).display;//Needed for when reinserting later

                    const bounds = target.getBoundingClientRect();

                    let startPos = getPos(e);

                    let lastPos = startPos;//To find direction

                    let offset = {
                        top : bounds.top - startPos.top,
                        bottom : bounds.bottom - startPos.top
                    };

                    target.style.position = "absolute";

                    // Create placeholder for visible placement
                    let placeholder = document.createElement("div");
                    placeholder.style.height = bounds.height + "px";
                    placeholder.style.backgroundColor = "yellow";
                    layers.insertBefore(placeholder, target.nextSibling);

                    let move = function(e){

                        let pos = getPos(e);

                        target.style.display = "none";//Hide
                        let hoverElement = document.elementFromPoint(e.clientX, e.clientY);
                        target.style.display = targetDisplay;

                        hoverIndex = elements.indexOf(hoverElement);

                        if (hoverIndex > -1) {//Is hovering sortable element

                            endIndex = hoverIndex;

                            let bcr = hoverElement.getBoundingClientRect();

                            let hoverCenter = bcr.top + (bcr.height/2); //middle of hovered element

                            if (
                                (pos.top < lastPos.top)//moving up
                                &&
                                (pos.top + offset.top)//drag top
                                <
                                hoverCenter
                            ) {
                                layers.insertBefore(placeholder, hoverElement);
                            } else if (
                                (pos.top > lastPos.top)//moving down
                                &&
                                (pos.top + offset.bottom)//drag bottom
                                >
                                hoverCenter
                            ) {
                                layers.insertBefore(placeholder, hoverElement.nextSibling);
                            }
                        }

                        target.style.left = (bounds.left + (pos.left - startPos.left)) + "px";
                        target.style.top = (bounds.top + (pos.top - startPos.top)) + "px";

                        lastPos = pos;

                    };

                    let selectStart = function(){return false;};

                    let stop = function(){

                        //Clear events
                        document.removeEventListener("mousemove", move);
                        document.removeEventListener("mouseup", stop);

                        //Remove unselectable properties and events
                        document.body.removeAttribute("unselectable");
                        document.body.style.MozUserSelect = "";
                        document.body.removeEventListener("selectstart", selectStart);

                        //Reset styles
                        target.style.position = "";
                        target.style.left = "";
                        target.style.top = "";

                        placeholder.replaceWith(target);

                        if (startIndex !== endIndex) {

                            elements.splice(endIndex, 0, elements.splice(startIndex, 1)[0]);//At position, delete 0, add element taken from elements

                            //Add custom event to layers element
                            layers.dispatchEvent(new CustomEvent("sorted", { detail: {startIndex:startIndex,endIndex:endIndex} }));

                            //Rearrange shapes in svg
                            if (endIndex > startIndex) {
                                svg.insertBefore(shapes[startIndex].el, shapes[endIndex].el.nextSibling);
                            } else {
                                svg.insertBefore(shapes[startIndex].el, shapes[endIndex].el);
                            }

                            //Rearrange shapes
                            shapes.splice(endIndex, 0, shapes.splice(startIndex, 1)[0]);

                        }

                    };

                    //Add drag and drag-end events
                    document.addEventListener("mousemove", move, false);
                    document.addEventListener("mouseup", stop);

                    //Add unselectable properties and events
                    document.body.setAttribute("unselectable", "on");
                    document.body.style.MozUserSelect = "none";
                    document.body.addEventListener("selectstart", selectStart);
                }

            });

            layers.addEventListener("sorted", (e) => {
                //console.log(e.detail);
            }, false);


            document.querySelector("#play").addEventListener("click", e => {
                e.preventDefault();
                let play = e.target;
                if (play.innerText==="Stop") {
                    play.innerText = "Play";
                    shapes.forEach(e=>{
                        e.el.setAttribute("opacity","1");
                    });
                    play.nextSibling.remove();
                } else {
                    play.innerText = "Stop";
                    shapes.forEach(e=>{
                        e.el.setAttribute("opacity",".3");
                    });
                    let i = 0;
                    let next = document.createElement("button");
                    next.innerText = "Next";
                    play.parentNode.insertBefore(next, play.nextSibling);
                    next.addEventListener("click", e => {
                        shapes[i].el.setAttribute("opacity","1");
                        if (!shapes[++i]) {
                            next.remove();
                            play.innerText = "Play";
                        }
                    });
                }
            });

            // layers.addEventListener("mouseover", (e) => {
            //     let index = [...layers.childNodes].indexOf(e.target);
            //     let shape = shapes[index];
            //     shape.el.setAttribute("stroke","#ff0000");
            // });
            //
            // layers.addEventListener("mouseout", (e) => {
            //     let index = [...layers.childNodes].indexOf(e.target);
            //     let shape = shapes[index];
            //     shape.el.setAttribute("stroke","#000000");
            // });

        </script>
        
    </body>
</html>