<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Test</title>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <style>
            html, body {
                height:100%;
            }
            body {
                margin:0;
                padding: 10px;
                background-color: #eee;
            }
            #editor {
                float: left;
            }
            svg {
                background-color: #fff;
            }
            #layers {
                float: left;
            }
            #layers li {
                cursor: default;
            }
            #layers .remove {
                cursor: pointer;
                margin:0 5px;
            }
            #controllers {
                clear: left;
                padding: 10px 0;
            }
            #examples {
                float: right;
            }
            #examples svg {
                width: 80px;
                height: 80px;
            }
        </style>
    </head>
    <body>


        
        <div id="editor" class="test">
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80"></path>
                <circle stroke="#000000" stroke-width="3" fill="transparent" cx="182" cy="124" r="36.235341863986875"></circle>
                <ellipse stroke="#000000" stroke-width="3" fill="transparent" cx="100" cy="132" rx="36" ry="52.5"></ellipse>
            </svg>
        </div>
        <ol id="layers"></ol>
        <div id="examples">
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80"></path>
                <circle stroke="#000000" stroke-width="3" fill="transparent" cx="182" cy="124" r="36.235341863986875"></circle>
                <ellipse stroke="#000000" stroke-width="3" fill="transparent" cx="100" cy="132" rx="36" ry="52.5"></ellipse>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M152 50 L84 121" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M152 50 L236 110" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M84 121 L128 124" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M128 124 L70 177" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M185 121 L244 165" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M192 185 L244 165" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M44 280 L126 183" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M280 270 L189 184" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M280 270 L187 288" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M236 110 L185 121" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M126 183 L70 177" opacity="1"></path>
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M44 280 L134 291" opacity="1"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" width="358" height="358" viewBox="0 0 358 358">
                <path stroke="#000000" stroke-width="3" fill="none" stroke-linejoin="round" d="M246 176 L235 80, 265 80, 235 40 C235 80, 225 80, 225 80"></path>
            </svg>
        </div>
        <div id="controllers">
            <button id="play">Play</button>
        </div>

        <script type="application/javascript" src="SVGDraw.js"></script>
        
        <script>

            let layers = document.querySelector("#layers");

            document.addEventListener("keyup", (e) => {

                if (e.key === "1") {
                    type = "path";
                }
                if (e.key === "2") {
                    type = "circle";
                }
                if (e.key === "3") {
                    type = "ellipse";
                }
                if (e.key === "l") {
                    draw = 1;
                }
                if (e.key === "m") {
                    draw = 0;
                }
                // if (e.key === "Delete") {
                //     console.log(Shape);
                // }
            });

            layers.addEventListener("mousedown", (e) => {

                let getPos = function(e){
                    return {
                        left : e.clientX,
                        top : e.clientY
                    };
                };

                if (e.target.nodeName.toLowerCase() === "span") {

                    let elements = [...layers.childNodes];

                    let startIndex = elements.indexOf(e.target.parentNode);

                    let Shape = shapes[startIndex];

                    Shape.el.remove();

                    shapes.splice(startIndex, 1);

                    e.target.parentNode.remove();

                }

                if (e.target.nodeName.toLowerCase() === "li") {

                    let elements = [...layers.childNodes];//Sortable elements

                    const target = e.target;

                    let startIndex = elements.indexOf(target);
                    let hoverIndex = null;
                    let endIndex = startIndex;

                    let targetDisplay = window.getComputedStyle(target).display;//Needed for when reinserting later

                    const bounds = target.getBoundingClientRect();

                    let startPos = getPos(e);

                    let lastPos = startPos;//To find direction

                    let offset = {
                        top : bounds.top - startPos.top,
                        bottom : bounds.bottom - startPos.top
                    };

                    target.style.position = "absolute";

                    // Create placeholder for visible placement
                    let placeholder = document.createElement("div");
                    placeholder.style.height = bounds.height + "px";
                    placeholder.style.backgroundColor = "yellow";
                    layers.insertBefore(placeholder, target.nextSibling);

                    let move = function(e){

                        let pos = getPos(e);

                        target.style.display = "none";//Hide
                        let hoverElement = document.elementFromPoint(e.clientX, e.clientY);
                        target.style.display = targetDisplay;

                        hoverIndex = elements.indexOf(hoverElement);

                        if (hoverIndex > -1) {//Is hovering sortable element

                            endIndex = hoverIndex;

                            let bcr = hoverElement.getBoundingClientRect();

                            let hoverCenter = bcr.top + (bcr.height/2); //middle of hovered element

                            if (
                                (pos.top < lastPos.top)//moving up
                                &&
                                (pos.top + offset.top)//drag top
                                <
                                hoverCenter
                            ) {
                                layers.insertBefore(placeholder, hoverElement);
                            } else if (
                                (pos.top > lastPos.top)//moving down
                                &&
                                (pos.top + offset.bottom)//drag bottom
                                >
                                hoverCenter
                            ) {
                                layers.insertBefore(placeholder, hoverElement.nextSibling);
                            }
                        }

                        target.style.left = (bounds.left + (pos.left - startPos.left)) + "px";
                        target.style.top = (bounds.top + (pos.top - startPos.top)) + "px";

                        lastPos = pos;

                    };

                    let selectStart = function(){return false;};

                    let stop = function(){

                        //Clear events
                        document.removeEventListener("mousemove", move);
                        document.removeEventListener("mouseup", stop);

                        //Remove unselectable properties and events
                        document.body.removeAttribute("unselectable");
                        document.body.style.MozUserSelect = "";
                        document.body.removeEventListener("selectstart", selectStart);

                        //Reset styles
                        target.style.position = "";
                        target.style.left = "";
                        target.style.top = "";

                        placeholder.replaceWith(target);

                        if (startIndex !== endIndex) {

                            elements.splice(endIndex, 0, elements.splice(startIndex, 1)[0]);//At position, delete 0, add element taken from elements

                            //Add custom event to layers element
                            layers.dispatchEvent(new CustomEvent("sorted", { detail: {startIndex:startIndex,endIndex:endIndex} }));

                            //Rearrange shapes
                            moveShape(startIndex, endIndex);

                        }

                    };

                    //Add drag and drag-end events
                    document.addEventListener("mousemove", move, false);
                    document.addEventListener("mouseup", stop);

                    //Add unselectable properties and events
                    document.body.setAttribute("unselectable", "on");
                    document.body.style.MozUserSelect = "none";
                    document.body.addEventListener("selectstart", selectStart);
                }

            });

            svg.addEventListener("added", (e) => {
                let b = document.createElement('li');
                b.innerHTML = e.detail.type + '<span class="remove">x</span>';
                layers.appendChild(b);
            }, false);

            document.querySelector("#play").addEventListener("click", e => {
                e.preventDefault();
                [...layers.children].forEach(el => {
                    el.style.fontWeight = "";
                });
                let play = e.target;
                if (play.innerText==="Stop") {
                    play.innerText = "Play";
                    shapes.forEach(e=>{
                        e.el.setAttribute("opacity","1");
                    });
                    play.nextSibling.remove();
                    [...layers.children].forEach(el => {
                        el.style.fontWeight = "";
                    });
                } else {
                    play.innerText = "Stop";
                    shapes.forEach(e=>{
                        e.el.setAttribute("opacity",".3");
                    });
                    let i = 0;
                    let next = document.createElement("button");
                    next.innerText = "Next";
                    play.parentNode.insertBefore(next, play.nextSibling);
                    next.addEventListener("click", e => {
                        shapes[i].el.setAttribute("opacity","1");
                        layers.children[i].style.fontWeight = "bold";
                        if (!shapes[++i]) {
                            next.remove();
                            play.innerText = "Play";
                        }
                    });
                }
            });

            addShapes();

            let examples = document.querySelector("#examples");

            examples.addEventListener("click", e => {
                if (e.target.nodeName === "svg") {
                    layers.innerHTML = "";
                    addShapes(e.target.innerHTML);
                }
            });

            layers.addEventListener("mouseover", (e) => {
                let index = [...layers.childNodes].indexOf(e.target);
                if (index > -1) {
                    let shape = shapes[index];
                    shape.el.setAttribute("stroke","#ff0000");
                }

            });

            layers.addEventListener("mouseout", (e) => {
                let index = [...layers.childNodes].indexOf(e.target);
                if (index > -1) {
                    let shape = shapes[index];
                    shape.el.setAttribute("stroke", "#000000");
                }
            });

        </script>
        
    </body>
</html>